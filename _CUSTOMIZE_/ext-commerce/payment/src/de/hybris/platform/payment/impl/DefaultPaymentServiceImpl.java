/*
 * [y] hybris Platform
 *
 * Copyright (c) 2018 SAP SE or an SAP affiliate company.  All rights reserved.
 *
 * This software is the confidential and proprietary information of SAP
 * ("Confidential Information"). You shall not disclose such Confidential
 * Information and shall use it only in accordance with the terms of the
 * license agreement you entered into with SAP.
 */
package de.hybris.platform.payment.impl;

import de.hybris.platform.core.model.order.OrderModel;
import de.hybris.platform.core.model.user.AddressModel;
import de.hybris.platform.core.model.user.UserModel;
import de.hybris.platform.payment.AdapterException;
import de.hybris.platform.payment.PaymentService;
import de.hybris.platform.payment.commands.request.AuthorizationRequest;
import de.hybris.platform.payment.commands.request.CaptureRequest;
import de.hybris.platform.payment.commands.request.CreateSubscriptionRequest;
import de.hybris.platform.payment.commands.request.DeleteSubscriptionRequest;
import de.hybris.platform.payment.commands.request.FollowOnRefundRequest;
import de.hybris.platform.payment.commands.request.PartialCaptureRequest;
import de.hybris.platform.payment.commands.request.StandaloneRefundRequest;
import de.hybris.platform.payment.commands.request.SubscriptionAuthorizationRequest;
import de.hybris.platform.payment.commands.request.SubscriptionDataRequest;
import de.hybris.platform.payment.commands.request.UpdateSubscriptionRequest;
import de.hybris.platform.payment.commands.request.VoidRequest;
import de.hybris.platform.payment.commands.result.AuthorizationResult;
import de.hybris.platform.payment.commands.result.CaptureResult;
import de.hybris.platform.payment.commands.result.RefundResult;
import de.hybris.platform.payment.commands.result.SubscriptionDataResult;
import de.hybris.platform.payment.commands.result.SubscriptionResult;
import de.hybris.platform.payment.commands.result.VoidResult;
import de.hybris.platform.payment.dto.BillingInfo;
import de.hybris.platform.payment.dto.CardInfo;
import de.hybris.platform.payment.dto.NewSubscription;
import de.hybris.platform.payment.enums.PaymentTransactionType;
import de.hybris.platform.payment.methods.CardPaymentService;
import de.hybris.platform.payment.model.PaymentTransactionEntryModel;
import de.hybris.platform.payment.model.PaymentTransactionModel;
import de.hybris.platform.payment.strategy.PaymentInfoCreatorStrategy;
import de.hybris.platform.payment.strategy.TransactionCodeGenerator;
import de.hybris.platform.servicelayer.i18n.CommonI18NService;
import de.hybris.platform.servicelayer.model.ModelService;
import de.hybris.platform.servicelayer.search.FlexibleSearchService;

import javax.annotation.Resource;

import java.math.BigDecimal;
import java.util.Currency;
import java.util.Date;


/**
 * Default implementation for PaymentService
 */
public class DefaultPaymentServiceImpl implements PaymentService
{
	@Resource
	private CardPaymentService cardPaymentService;
	@Resource
	private CommonI18NService commonI18NService;
	@Resource
	private ModelService modelService;
	@Resource
	private FlexibleSearchService flexibleSearchService;

	private TransactionCodeGenerator transactionCodeGenerator;
	private PaymentInfoCreatorStrategy paymentInfoCreator;

	/**
	 * Authorize payment.<br/>
	 * Status, transaction and request related informations are available via the related
	 * {@link PaymentTransactionEntryModel},/<br>
	 * Informations about the related order will be accessible via the referenced {@link PaymentTransactionModel} (see:
	 * {@link PaymentTransactionEntryModel#getPaymentTransaction()} and
	 * {@link PaymentTransactionEntryModel#setPaymentTransaction(PaymentTransactionModel)}
	 *
	 * @param merchantTransactionCode
	 * 		the transaction code. Code of the internally generated {@link PaymentTransactionModel} and code-base of
	 * 		the final {@link PaymentTransactionEntryModel#CODE} which will be generated by using the injected
	 * 		{@link TransactionCodeGenerator}
	 * @param amount
	 * 		the amount
	 * @param currency
	 * 		the currency
	 * @param deliveryAddress
	 * 		the delivery address
	 * @return Payment Transaction Entry
	 * @throws AdapterException
	 */
	@Override
	public PaymentTransactionEntryModel authorize(final String merchantTransactionCode, final BigDecimal amount,
			final Currency currency, final AddressModel deliveryAddress, final String subscriptionID)
	{
		final BillingInfo shippingInfo = createBillingInfo(deliveryAddress);

		final PaymentTransactionModel transaction = getModelService().create(PaymentTransactionModel.class);
		transaction.setCode(merchantTransactionCode);
		transaction.setPlannedAmount(amount);

		return authorizeInternal(transaction, amount, currency, shippingInfo, null, subscriptionID, null, null);
	}

	@Override
	public PaymentTransactionEntryModel authorize(final String merchantTransactionCode, final BigDecimal amount,
			final Currency currency, final AddressModel deliveryAddress, final String subscriptionID, final String cv2,
			final String paymentProvider)
	{
		final BillingInfo shippingInfo = createBillingInfo(deliveryAddress);

		final PaymentTransactionModel transaction = getModelService().create(PaymentTransactionModel.class);
		transaction.setCode(merchantTransactionCode);
		transaction.setPlannedAmount(amount);

		return authorizeInternal(transaction, amount, currency, shippingInfo, null, subscriptionID, cv2, paymentProvider);

	}

	@Override
	public PaymentTransactionEntryModel authorize(final String merchantTransactionCode, final BigDecimal amount,
			final Currency currency, final AddressModel deliveryAddress, final AddressModel paymentAddress, final CardInfo card)
	{
		final BillingInfo shippingInfo = createBillingInfo(deliveryAddress, paymentAddress, card);

		final PaymentTransactionModel transaction = getModelService().create(PaymentTransactionModel.class);
		transaction.setCode(merchantTransactionCode);
		transaction.setPlannedAmount(amount);

		return authorizeInternal(transaction, amount, currency, shippingInfo, card, null, null, null);
	}

	/**
	 * authorize payment<br>
	 * note: the code of the assigned payment transaction will be used as code-basecode during the
	 * {@link PaymentTransactionEntryModel#CODE} code generation process, which represents the main benefit of this
	 * method.
	 *
	 * @param transaction
	 * 		the payment transaction
	 * @param amount
	 * 		the amount
	 * @param currency
	 * 		the currency
	 * @param deliveryAddress
	 * 		the delivery address
	 * @param paymentAddress
	 * 		the payment address
	 * @param card
	 * 		the card
	 * @return Payment Transaction Entry
	 * @throws AdapterException
	 */
	@Override
	public PaymentTransactionEntryModel authorize(final PaymentTransactionModel transaction, final BigDecimal amount,
			final Currency currency, final AddressModel deliveryAddress, final AddressModel paymentAddress, final CardInfo card)
	{
		final BillingInfo shippingInfo = createBillingInfo(deliveryAddress, paymentAddress, card);

		return authorizeInternal(transaction, amount, currency, shippingInfo, card, null, null, null);
	}

	/**
	 * authorize payment<br>
	 * note: the code of the assigned payment transaction will be used as code-basecode during the
	 * {@link PaymentTransactionEntryModel#CODE} code generation process, which represents the main benefit of this
	 * method.
	 *
	 * @param transaction
	 * 		the payment transaction
	 * @param amount
	 * 		the amount
	 * @param currency
	 * 		the currency
	 * @param deliveryAddress
	 * 		the delivery address
	 * @param subscriptionID
	 * 		will be used for identifying the user profile (see payment tokenization)
	 * @return Payment Transaction Entry
	 * @throws AdapterException
	 */
	@Override
	public PaymentTransactionEntryModel authorize(final PaymentTransactionModel transaction, final BigDecimal amount,
			final Currency currency, final AddressModel deliveryAddress, final String subscriptionID, final String paymentprovider)
	{
		final BillingInfo shippingInfo = createBillingInfo(deliveryAddress);

		return authorizeInternal(transaction, amount, currency, shippingInfo, null, subscriptionID, null, paymentprovider);
	}

	@Override
	public PaymentTransactionEntryModel authorize(final PaymentTransactionModel transaction, final BigDecimal amount,
			final Currency currency, final AddressModel deliveryAddress, final String subscriptionID)
	{
		final BillingInfo shippingInfo = createBillingInfo(deliveryAddress);

		return authorizeInternal(transaction, amount, currency, shippingInfo, null, subscriptionID, null, null);
	}

	/**
	 * ... internally used authorization.<br>
	 *
	 * @param transaction
	 * 		the payment transaction
	 * @param amount
	 * 		the amount we ant to authorize
	 * @param currency
	 * 		the related currency of the amount
	 * @param shippingInfo
	 * 		the shipping info
	 * @param card
	 * 		the card info
	 * @param subscriptionID
	 * 		will be used for identifying the user profile (see payment tokenization)
	 * @throws AdapterException
	 */
	protected PaymentTransactionEntryModel authorizeInternal(final PaymentTransactionModel transaction, //NOSONAR
			final BigDecimal amount, final Currency currency, final BillingInfo shippingInfo, final CardInfo card,
			final String subscriptionID, final String cv2, final String paymentProvider)
	{
		final AuthorizationResult result;
		final PaymentTransactionType paymentTransactionType = PaymentTransactionType.AUTHORIZATION;
		final String newEntryCode = getNewPaymentTransactionEntryCode(transaction, paymentTransactionType);
		if (subscriptionID == null)
		{
			result = getCardPaymentService().authorize(new AuthorizationRequest(newEntryCode, card, currency, amount, shippingInfo));
		}
		else
		{
			result = getCardPaymentService().authorize(
					new SubscriptionAuthorizationRequest(newEntryCode, subscriptionID, currency, amount, shippingInfo, cv2,
							paymentProvider));
		}
		transaction.setRequestId(result.getRequestId());
		transaction.setRequestToken(result.getRequestToken());
		transaction.setPaymentProvider(result.getPaymentProvider());
		getModelService().save(transaction);

		final PaymentTransactionEntryModel entry = getModelService().create(PaymentTransactionEntryModel.class);
		entry.setAmount(result.getTotalAmount());
		if (result.getCurrency() != null)
		{
			entry.setCurrency(getCommonI18NService().getCurrency(result.getCurrency().getCurrencyCode()));
		}
		entry.setType(paymentTransactionType);
		entry.setTime(result.getAuthorizationTime() == null ? new Date() : result.getAuthorizationTime());
		entry.setPaymentTransaction(transaction);
		entry.setRequestId(result.getRequestId());
		entry.setRequestToken(result.getRequestToken());
		entry.setTransactionStatus(result.getTransactionStatus().toString());
		entry.setTransactionStatusDetails(result.getTransactionStatusDetails().toString());
		entry.setCode(newEntryCode);
		if (subscriptionID != null)
		{
			entry.setSubscriptionID(subscriptionID);
		}
		getModelService().save(entry);
		getModelService().refresh(transaction);
		return entry;
	}

	/**
	 * Generate new merchant transaction code for payment transaction entries based on code for whole transaction
	 */
	@Override
	public String getNewPaymentTransactionEntryCode(final PaymentTransactionModel transaction,
			final PaymentTransactionType paymentTransactionType)
	{
		if (transaction.getEntries() == null)
		{
			return transaction.getCode() + "-" + paymentTransactionType.getCode() + "-1";
		}
		return transaction.getCode() + "-" + paymentTransactionType.getCode() + "-" + (transaction.getEntries().size() + 1);
	}

	/**
	 * creates the billing info based on the assigned delivery address instance. In case the deliveryAddress is null, we
	 * will use the billing info of the assigned CardInfo instance.
	 *
	 * @param deliveryAddress
	 * 		the delivery address
	 * @param paymentAddress
	 * 		the payment address
	 * @param card
	 * 		the card info
	 * @return the billing info
	 */
	protected BillingInfo createBillingInfo(final AddressModel deliveryAddress, final AddressModel paymentAddress,
			final CardInfo card)
	{
		if (card != null && card.getBillingInfo() == null && paymentAddress != null)
		{
			final BillingInfo billingInfo = new BillingInfo();
			billingInfo.setCity(paymentAddress.getTown());
			if (paymentAddress.getCountry() != null)
			{
				billingInfo.setCountry(paymentAddress.getCountry().getIsocode());
			}
			billingInfo.setEmail(paymentAddress.getEmail());
			billingInfo.setFirstName(paymentAddress.getFirstname());
			billingInfo.setLastName(paymentAddress.getLastname());
			billingInfo.setPhoneNumber(paymentAddress.getPhone1());
			billingInfo.setPostalCode(paymentAddress.getPostalcode());
			if (paymentAddress.getRegion() != null)
			{
				billingInfo.setState(paymentAddress.getRegion().getName());
			}
			billingInfo.setStreet1(paymentAddress.getStreetname());
			billingInfo.setStreet2(paymentAddress.getStreetnumber());
			card.setBillingInfo(billingInfo);
		}

		BillingInfo shippingInfo = null;
		if (deliveryAddress == null)
		{
			if (card != null)
			{
				shippingInfo = card.getBillingInfo();
			}
		}
		else
		{
			shippingInfo = new BillingInfo();
			shippingInfo.setCity(deliveryAddress.getTown());
			if (deliveryAddress.getCountry() != null)
			{
				shippingInfo.setCountry(deliveryAddress.getCountry().getIsocode());
			}
			shippingInfo.setEmail(deliveryAddress.getEmail());
			shippingInfo.setFirstName(deliveryAddress.getFirstname());
			shippingInfo.setLastName(deliveryAddress.getLastname());
			shippingInfo.setPhoneNumber(deliveryAddress.getPhone1());
			shippingInfo.setPostalCode(deliveryAddress.getPostalcode());
			if (deliveryAddress.getRegion() != null)
			{
				shippingInfo.setState(deliveryAddress.getRegion().getName());
			}
			shippingInfo.setStreet1(deliveryAddress.getStreetname());
			shippingInfo.setStreet2(deliveryAddress.getStreetnumber());
		}
		return shippingInfo;
	}

	/**
	 * address DTO 2 address DTO
	 */
	protected BillingInfo createBillingInfo(final AddressModel address)
	{
		if (address == null)
		{
			return null;
		}

		final BillingInfo billingInfo = new BillingInfo();

		billingInfo.setCity(address.getTown());
		if (address.getCountry() != null)
		{
			billingInfo.setCountry(address.getCountry().getIsocode());
		}
		billingInfo.setEmail(address.getEmail());
		billingInfo.setFirstName(address.getFirstname());
		billingInfo.setLastName(address.getLastname());
		billingInfo.setPhoneNumber(address.getPhone1());
		billingInfo.setPostalCode(address.getPostalcode());
		if (address.getRegion() != null)
		{
			billingInfo.setState(address.getRegion().getName());
		}
		billingInfo.setStreet1(address.getStreetname());
		billingInfo.setStreet2(address.getStreetnumber());

		return billingInfo;
	}


	/**
	 * authorize payment. the injected {@link de.hybris.platform.payment.strategy.TransactionCodeGenerator} will be used
	 * for determining the 'merchant transaction code' .
	 *
	 * @param order
	 * 		the order
	 * @param card
	 * 		the card
	 * @return Payment Transaction Entry
	 * @throws AdapterException
	 * @deprecated Since 4.2.2 use any of the other authorize methods
	 */
	@SuppressWarnings("deprecation")
	@Override
	@Deprecated
	public PaymentTransactionEntryModel authorize(final OrderModel order, final CardInfo card) //NOSONAR
	{
		final String mtc = getTransactionCodeGenerator().generateCode(order.getCode());
		final PaymentTransactionEntryModel transactionEntry = authorize(mtc,
				BigDecimal.valueOf(order.getTotalPrice().doubleValue()), Currency.getInstance(order.getCurrency().getIsocode()),
				order.getDeliveryAddress(), order.getPaymentAddress(), card);
		transactionEntry.getPaymentTransaction().setOrder(order);
		return transactionEntry;
	}

	@Override
	public PaymentTransactionEntryModel capture(final PaymentTransactionModel transaction)
	{
		PaymentTransactionEntryModel auth = null;
		for (final PaymentTransactionEntryModel pte : transaction.getEntries())
		{
			if (pte.getType().equals(PaymentTransactionType.AUTHORIZATION))
			{
				auth = pte;
				break;
			}
		}

		if (auth == null)
		{
			throw new AdapterException("Could not capture without authorization");
		}
		final PaymentTransactionType transactionType = PaymentTransactionType.CAPTURE;
		final String newEntryCode = getNewPaymentTransactionEntryCode(transaction, transactionType);

		final CaptureResult result = getCardPaymentService().capture(
				new CaptureRequest(newEntryCode, transaction.getRequestId(), transaction.getRequestToken(),
						Currency.getInstance(auth.getCurrency().getIsocode()), auth.getAmount(), transaction.getPaymentProvider(),
						auth.getSubscriptionID()));

		final PaymentTransactionEntryModel entry = getModelService().create(PaymentTransactionEntryModel.class);
		entry.setAmount(result.getTotalAmount());
		if (result.getCurrency() != null)
		{
			entry.setCurrency(getCommonI18NService().getCurrency(result.getCurrency().getCurrencyCode()));
		}
		entry.setType(transactionType);
		entry.setRequestId(result.getRequestId());
		entry.setRequestToken(result.getRequestToken());
		entry.setTime(result.getRequestTime() == null ? new Date() : result.getRequestTime());
		entry.setPaymentTransaction(transaction);
		entry.setTransactionStatus(result.getTransactionStatus().toString());
		entry.setTransactionStatusDetails(result.getTransactionStatusDetails().toString());
		entry.setCode(newEntryCode);
		getModelService().save(entry);
		return entry;
	}

	@Override
	public PaymentTransactionEntryModel cancel(final PaymentTransactionEntryModel transaction)
	{
		final PaymentTransactionType transactionType = PaymentTransactionType.CANCEL;
		final String newEntryCode = getNewPaymentTransactionEntryCode(transaction.getPaymentTransaction(), transactionType);
		final VoidResult result = getCardPaymentService().voidCreditOrCapture(
				new VoidRequest(newEntryCode, transaction.getRequestId(), transaction.getRequestToken(),
						transaction.getPaymentTransaction().getPaymentProvider(),
						transaction.getCurrency() == null ? null : Currency.getInstance(transaction.getCurrency().getIsocode()),
						transaction.getAmount()));

		final PaymentTransactionEntryModel entry = getModelService().create(PaymentTransactionEntryModel.class);
		if (result.getCurrency() != null)
		{
			entry.setCurrency(getCommonI18NService().getCurrency(result.getCurrency().getCurrencyCode()));

		}
		entry.setType(transactionType);
		entry.setTime(result.getRequestTime() == null ? new Date() : result.getRequestTime());
		entry.setPaymentTransaction(transaction.getPaymentTransaction());
		entry.setRequestId(result.getRequestId());
		entry.setAmount(result.getAmount());
		entry.setRequestToken(result.getRequestToken());
		entry.setTransactionStatus(result.getTransactionStatus().toString());
		entry.setTransactionStatusDetails(result.getTransactionStatusDetails().toString());
		entry.setCode(newEntryCode);
		getModelService().save(entry);
		return entry;
	}

	@Override
	public PaymentTransactionEntryModel refundFollowOn(final PaymentTransactionModel transaction, final BigDecimal amount)
	{
		PaymentTransactionEntryModel auth = null;
		for (final PaymentTransactionEntryModel pte : transaction.getEntries())
		{
			if (pte.getType().equals(PaymentTransactionType.AUTHORIZATION))
			{
				auth = pte;
				break;
			}
		}

		if (auth == null)
		{
			throw new AdapterException("Could not refund follow-on without authorization");
		}

		final PaymentTransactionType transactionType = PaymentTransactionType.REFUND_FOLLOW_ON;
		final String newEntryCode = getNewPaymentTransactionEntryCode(transaction, transactionType);
		final RefundResult result = getCardPaymentService().refundFollowOn(
				new FollowOnRefundRequest(newEntryCode, transaction.getRequestId(), transaction.getRequestToken(),
						Currency.getInstance(auth.getCurrency().getIsocode()), amount, transaction.getPaymentProvider()));

		final PaymentTransactionEntryModel entry = getModelService().create(PaymentTransactionEntryModel.class);
		if (result.getCurrency() != null)
		{
			entry.setCurrency(getCommonI18NService().getCurrency(result.getCurrency().getCurrencyCode()));
		}
		entry.setType(transactionType);
		entry.setTime(result.getRequestTime() == null ? new Date() : result.getRequestTime());
		entry.setPaymentTransaction(transaction);
		entry.setAmount(result.getTotalAmount());
		entry.setRequestId(result.getRequestId());
		entry.setRequestToken(result.getRequestToken());
		entry.setTransactionStatus(result.getTransactionStatus().toString());
		entry.setTransactionStatusDetails(result.getTransactionStatusDetails().toString());
		entry.setCode(newEntryCode);
		getModelService().save(entry);
		return entry;
	}


	/**
	 * @deprecated Since 4.2.2 use {@link #refundStandalone(String, BigDecimal, Currency, AddressModel, CardInfo)} instead
	 */
	@Deprecated
	@Override
	@SuppressWarnings("deprecation")
	public PaymentTransactionEntryModel refundStandalone(final StandaloneRefundRequest request) //NOSONAR
	{
		final RefundResult result = getCardPaymentService().refundStandalone(request);

		final PaymentTransactionModel transaction = getModelService().create(PaymentTransactionModel.class);
		transaction.setRequestId(result.getRequestId());
		transaction.setRequestToken(result.getRequestToken());
		transaction.setPaymentProvider(result.getPaymentProvider());
		getModelService().save(transaction);

		final PaymentTransactionEntryModel entry = getModelService().create(PaymentTransactionEntryModel.class);
		if (result.getCurrency() != null)
		{
			entry.setCurrency(getCommonI18NService().getCurrency(result.getCurrency().getCurrencyCode()));
		}
		final PaymentTransactionType transactionType = PaymentTransactionType.REFUND_STANDALONE;
		entry.setType(transactionType);
		entry.setTime(result.getRequestTime() == null ? new Date() : result.getRequestTime());
		entry.setPaymentTransaction(transaction);
		entry.setAmount(result.getTotalAmount());
		entry.setRequestId(result.getRequestId());
		entry.setRequestToken(result.getRequestToken());
		entry.setTransactionStatus(result.getTransactionStatus().toString());
		entry.setTransactionStatusDetails(result.getTransactionStatusDetails().toString());
		entry.setCode(getNewPaymentTransactionEntryCode(transaction, transactionType));
		getModelService().save(entry);
		return entry;
	}

	@Override
	public PaymentTransactionEntryModel refundStandalone(final String merchantTransactionCode, final BigDecimal amount,
			final Currency currency, final AddressModel paymentAddress, final CardInfo card)
	{
		return refundStandalone(merchantTransactionCode, amount, currency, paymentAddress, card, null, null);
	}

	@Override
	public PaymentTransactionEntryModel refundStandalone(final String merchantTransactionCode, final BigDecimal amount,
			final Currency currency, final AddressModel paymentAddress, final CardInfo card, final String providerName,
			final String subscriptionId)
	{
		final BillingInfo billTo = createBillingInfo(paymentAddress);
		final StandaloneRefundRequest request = new StandaloneRefundRequest(merchantTransactionCode, subscriptionId, billTo, card,
				currency, amount, providerName);

		final RefundResult result = getCardPaymentService().refundStandalone(request);

		final PaymentTransactionModel transaction = getModelService().create(PaymentTransactionModel.class);
		transaction.setRequestId(result.getRequestId());
		transaction.setRequestToken(result.getRequestToken());
		transaction.setPaymentProvider(result.getPaymentProvider());
		getModelService().save(transaction);

		final PaymentTransactionEntryModel entry = getModelService().create(PaymentTransactionEntryModel.class);
		if (result.getCurrency() != null)
		{
			entry.setCurrency(getCommonI18NService().getCurrency(result.getCurrency().getCurrencyCode()));
		}
		final PaymentTransactionType transactionType = PaymentTransactionType.REFUND_STANDALONE;
		entry.setType(transactionType);
		entry.setTime(result.getRequestTime() == null ? new Date() : result.getRequestTime());
		entry.setPaymentTransaction(transaction);
		entry.setAmount(result.getTotalAmount());
		entry.setRequestId(result.getRequestId());
		entry.setRequestToken(result.getRequestToken());

		entry.setTransactionStatus(result.getTransactionStatus().toString());
		entry.setTransactionStatusDetails(result.getTransactionStatusDetails().toString());
		entry.setCode(getNewPaymentTransactionEntryCode(transaction, transactionType));
		getModelService().save(entry);
		return entry;
	}

	@Override
	public PaymentTransactionEntryModel partialCapture(final PaymentTransactionModel transaction, final BigDecimal amount)
	{
		PaymentTransactionEntryModel auth = null;
		int capturesSize = 1;
		final PaymentTransactionType transactionType = PaymentTransactionType.PARTIAL_CAPTURE;
		for (final PaymentTransactionEntryModel pte : transaction.getEntries())
		{
			if (pte.getType().equals(PaymentTransactionType.AUTHORIZATION))
			{
				auth = pte;
			}
			else if (pte.getType().equals(transactionType))
			{
				capturesSize++;
			}
		}

		if (auth == null)
		{
			throw new AdapterException("Could not capture partially without authorization");
		}

		final String newEntryCode = getNewPaymentTransactionEntryCode(transaction, transactionType);
		final CaptureResult result = getCardPaymentService().partialCapture(
				new PartialCaptureRequest(newEntryCode, transaction.getRequestId(), transaction.getRequestToken(),
						Currency.getInstance(auth.getCurrency().getIsocode()), amount, Integer.toString(capturesSize),
						transaction.getPaymentProvider()));

		final PaymentTransactionEntryModel entry = getModelService().create(PaymentTransactionEntryModel.class);
		entry.setAmount(result.getTotalAmount());
		if (result.getCurrency() != null)
		{
			entry.setCurrency(getCommonI18NService().getCurrency(result.getCurrency().getCurrencyCode()));
		}
		entry.setType(transactionType);
		entry.setTime(result.getRequestTime() == null ? new Date() : result.getRequestTime());
		entry.setPaymentTransaction(transaction);
		entry.setRequestId(result.getRequestId());
		entry.setRequestToken(result.getRequestToken());
		entry.setTransactionStatus(result.getTransactionStatus().toString());
		entry.setTransactionStatusDetails(result.getTransactionStatusDetails().toString());
		entry.setCode(newEntryCode);
		getModelService().save(entry);
		return entry;
	}

	/**
	 * Get {@link PaymentTransactionModel} by code
	 *
	 * @param code
	 * 		the code of the {@link PaymentTransactionModel} we were looking for
	 * @return the {@link PaymentTransactionModel}
	 * @throws de.hybris.platform.servicelayer.exceptions.ModelNotFoundException
	 * 		if nothing was found
	 * @throws de.hybris.platform.servicelayer.exceptions.AmbiguousIdentifierException
	 * 		if by the given searchparams to many models where found
	 */
	@Override
	public PaymentTransactionModel getPaymentTransaction(final String code)
	{
		final PaymentTransactionModel example = new PaymentTransactionModel();
		example.setCode(code);
		return getFlexibleSearchService().getModelByExample(example);
	}

	/**
	 * Get {@link PaymentTransactionEntryModel} by code
	 *
	 * @param code
	 * 		the code of the {@link PaymentTransactionModel} we were looking for
	 * @return the {@link PaymentTransactionModel}
	 * @throws de.hybris.platform.servicelayer.exceptions.ModelNotFoundException
	 * 		if nothing was found
	 * @throws de.hybris.platform.servicelayer.exceptions.AmbiguousIdentifierException
	 * 		if by the given searchparams to many models where found
	 */
	@Override
	public PaymentTransactionEntryModel getPaymentTransactionEntry(final String code)
	{
		final PaymentTransactionEntryModel example = new PaymentTransactionEntryModel();
		example.setCode(code);

		return getFlexibleSearchService().getModelByExample(example);
	}

	/**
	 * Attaches PaymentInfo to the assigned PaymentTransactionModel instance by using the configured
	 * PaymentInfoCreatorStrategy. <br>
	 * You can call this method after/before authorization by yourself if there is a need for it.
	 *
	 * @param paymentTransactionModel
	 * 		the payment transaction
	 * @param userModel
	 * 		the user
	 * @param cardInfo
	 * 		the card info
	 * @param amount
	 * 		the amount
	 */
	@Override
	public void attachPaymentInfo(final PaymentTransactionModel paymentTransactionModel, final UserModel userModel,
			final CardInfo cardInfo, final BigDecimal amount)
	{
		getPaymentInfoCreator().attachPaymentInfo(paymentTransactionModel, userModel, cardInfo, amount);
	}

	@Override
	public NewSubscription createSubscription(final PaymentTransactionModel transaction, final AddressModel paymentAddress,
			final CardInfo card)
	{

		PaymentTransactionEntryModel auth = null;
		for (final PaymentTransactionEntryModel pte : transaction.getEntries())
		{
			if (pte.getType().equals(PaymentTransactionType.AUTHORIZATION))
			{
				auth = pte;
				break;
			}
		}

		if (auth == null)
		{
			throw new AdapterException("Could not create a subscription without authorization");
		}

		final PaymentTransactionType transactionType = PaymentTransactionType.CREATE_SUBSCRIPTION;
		final String newEntryCode = getNewPaymentTransactionEntryCode(transaction, transactionType);
		final CreateSubscriptionRequest request = new CreateSubscriptionRequest(newEntryCode, createBillingInfo(paymentAddress),
				Currency.getInstance(auth.getCurrency().getIsocode()), card, transaction.getRequestId(),
				transaction.getRequestToken(), transaction.getPaymentProvider());

		final SubscriptionResult result = getCardPaymentService().createSubscription(request);

		final PaymentTransactionEntryModel entry = getModelService().create(PaymentTransactionEntryModel.class);
		entry.setType(transactionType);
		entry.setRequestId(result.getRequestId());
		entry.setRequestToken(result.getRequestToken());
		entry.setTime(new Date());
		entry.setPaymentTransaction(transaction);
		entry.setTransactionStatus(result.getTransactionStatus().toString());
		entry.setTransactionStatusDetails(result.getTransactionStatusDetails().toString());
		entry.setCode(newEntryCode);
		getModelService().save(entry);

		final NewSubscription newSubscription = new NewSubscription();
		newSubscription.setTransactionEntry(entry);
		newSubscription.setSubscriptionID(result.getSubscriptionID());

		return newSubscription;
	}

	@Override
	public NewSubscription createSubscription(final String merchantTransactionCode, final String paymentProvider,
			final Currency currency, final AddressModel paymentAddress, final CardInfo card)
	{
		final CreateSubscriptionRequest request = new CreateSubscriptionRequest(merchantTransactionCode,
				createBillingInfo(paymentAddress), currency, card, null, null, paymentProvider);

		final PaymentTransactionModel transaction = getModelService().create(PaymentTransactionModel.class);
		transaction.setCode(merchantTransactionCode);

		final SubscriptionResult result = getCardPaymentService().createSubscription(request);
		transaction.setRequestId(result.getRequestId());
		transaction.setRequestToken(result.getRequestToken());
		transaction.setPaymentProvider(paymentProvider);
		getModelService().save(transaction);

		final PaymentTransactionEntryModel entry = getModelService().create(PaymentTransactionEntryModel.class);
		final PaymentTransactionType transactionType = PaymentTransactionType.CREATE_SUBSCRIPTION;
		entry.setType(transactionType);
		entry.setRequestId(result.getRequestId());
		entry.setRequestToken(result.getRequestToken());
		entry.setTime(new Date());
		entry.setPaymentTransaction(transaction);
		entry.setTransactionStatus(result.getTransactionStatus().toString());
		if (result.getTransactionStatusDetails() != null)
		{
			entry.setTransactionStatusDetails(result.getTransactionStatusDetails().toString());
		}
		entry.setCode(getNewPaymentTransactionEntryCode(transaction, transactionType));
		getModelService().save(entry);

		final NewSubscription newSubscription = new NewSubscription();
		newSubscription.setTransactionEntry(entry);
		newSubscription.setSubscriptionID(result.getSubscriptionID());

		return newSubscription;
	}

	@Override
	public PaymentTransactionEntryModel updateSubscription(final String merchantTransactionCode, final String subscriptionID,
			final String paymentProvider, final AddressModel paymentAddress, final CardInfo card)
	{
		if (paymentAddress == null && card == null)
		{
			return null; // Not much to do
		}

		final PaymentTransactionModel transaction = getModelService().create(PaymentTransactionModel.class);
		transaction.setCode(merchantTransactionCode);

		final SubscriptionResult result = getCardPaymentService().updateSubscription(
				new UpdateSubscriptionRequest(getTransactionCodeGenerator().generateCode(transaction.getCode()), subscriptionID,
						paymentProvider, createBillingInfo(paymentAddress), card));
		transaction.setRequestId(result.getRequestId());
		transaction.setRequestToken(result.getRequestToken());
		transaction.setPaymentProvider(paymentProvider);
		getModelService().save(transaction);

		final PaymentTransactionEntryModel entry = getModelService().create(PaymentTransactionEntryModel.class);
		final PaymentTransactionType transactionType = PaymentTransactionType.UPDATE_SUBSCRIPTION;
		entry.setType(transactionType);
		entry.setTime(new Date());
		entry.setPaymentTransaction(transaction);
		entry.setRequestId(result.getRequestId());
		entry.setRequestToken(result.getRequestToken());
		entry.setTransactionStatus(result.getTransactionStatus().toString());
		entry.setTransactionStatusDetails(result.getTransactionStatusDetails().toString());
		entry.setCode(getNewPaymentTransactionEntryCode(transaction, transactionType));
		entry.setSubscriptionID(subscriptionID);
		getModelService().save(entry);

		return entry;
	}

	@Override
	public PaymentTransactionEntryModel getSubscriptionData(final String merchantTransactionCode, final String subscriptionID,
			final String paymentProvider, final BillingInfo billingInfo, final CardInfo card)
	{
		if (billingInfo == null && card == null)
		{
			return null; // Not much to do
		}

		final PaymentTransactionModel transaction = getModelService().create(PaymentTransactionModel.class);
		transaction.setCode(merchantTransactionCode);

		final SubscriptionDataResult result = getCardPaymentService().getSubscriptionData(
				new SubscriptionDataRequest(getTransactionCodeGenerator().generateCode(transaction.getCode()), subscriptionID,
						paymentProvider));
		transaction.setRequestId(result.getRequestId());
		transaction.setRequestToken(result.getRequestToken());
		transaction.setPaymentProvider(paymentProvider);
		getModelService().save(transaction);

		final PaymentTransactionEntryModel entry = getModelService().create(PaymentTransactionEntryModel.class);
		final PaymentTransactionType transactionType = PaymentTransactionType.GET_SUBSCRIPTION_DATA;
		entry.setType(transactionType);
		entry.setTime(new Date());
		entry.setPaymentTransaction(transaction);
		entry.setRequestId(result.getRequestId());
		entry.setRequestToken(result.getRequestToken());
		entry.setTransactionStatus(result.getTransactionStatus().toString());
		entry.setTransactionStatusDetails(result.getTransactionStatusDetails().toString());
		entry.setCode(getNewPaymentTransactionEntryCode(transaction, transactionType));
		getModelService().save(entry);

		if (billingInfo != null)
		{
			billingInfo.copy(result.getBillingInfo());
		}
		if (card != null)
		{
			card.copy(result.getCard());
		}

		return entry;
	}

	@Override
	public PaymentTransactionEntryModel deleteSubscription(final String merchantTransactionCode, final String subscriptionID,
			final String paymentProvider)
	{
		final PaymentTransactionModel transaction = getModelService().create(PaymentTransactionModel.class);
		transaction.setCode(merchantTransactionCode);

		final SubscriptionResult result = getCardPaymentService().deleteSubscription(
				new DeleteSubscriptionRequest(getTransactionCodeGenerator().generateCode(transaction.getCode()), subscriptionID,
						paymentProvider));
		transaction.setRequestId(result.getRequestId());
		transaction.setRequestToken(result.getRequestToken());
		transaction.setPaymentProvider(paymentProvider);
		getModelService().save(transaction);

		final PaymentTransactionEntryModel entry = getModelService().create(PaymentTransactionEntryModel.class);
		final PaymentTransactionType transactionType = PaymentTransactionType.DELETE_SUBSCRIPTION;
		entry.setType(transactionType);
		entry.setTime(new Date());
		entry.setPaymentTransaction(transaction);
		entry.setRequestId(result.getRequestId());
		entry.setRequestToken(result.getRequestToken());
		entry.setTransactionStatus(result.getTransactionStatus().toString());
		entry.setTransactionStatusDetails(result.getTransactionStatusDetails().toString());
		entry.setCode(getNewPaymentTransactionEntryCode(transaction, transactionType));
		entry.setSubscriptionID(subscriptionID);
		getModelService().save(entry);

		return entry;
	}

	protected CommonI18NService getCommonI18NService()
	{
		return commonI18NService;
	}

	public void setCommonI18NService(final CommonI18NService commonI18NService)
	{
		this.commonI18NService = commonI18NService;
	}

	protected ModelService getModelService()
	{
		return modelService;
	}

	public void setModelService(final ModelService modelService)
	{
		this.modelService = modelService;
	}

	protected FlexibleSearchService getFlexibleSearchService()
	{
		return flexibleSearchService;
	}

	public void setFlexibleSearchService(final FlexibleSearchService flexibleSearchService)
	{
		this.flexibleSearchService = flexibleSearchService;
	}

	protected PaymentInfoCreatorStrategy getPaymentInfoCreator()
	{
		return paymentInfoCreator;
	}

	public void setPaymentInfoCreator(final PaymentInfoCreatorStrategy paymentInfoCreator)
	{
		this.paymentInfoCreator = paymentInfoCreator;
	}

	protected TransactionCodeGenerator getTransactionCodeGenerator()
	{
		return transactionCodeGenerator;
	}

	public void setTransactionCodeGenerator(final TransactionCodeGenerator transactionCodeGenerator)
	{
		this.transactionCodeGenerator = transactionCodeGenerator;
	}

	protected CardPaymentService getCardPaymentService()
	{
		return cardPaymentService;
	}

	public void setCardPaymentService(final CardPaymentService cardPaymentService)
	{
		this.cardPaymentService = cardPaymentService;
	}


}
